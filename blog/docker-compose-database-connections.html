<!DOCTYPE html>

<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" href="../favicon.ico" />
    <link rel="apple-touch-icon" href="../favicon.png" />
    <meta charset="UTF-8">
    <title>Blogeintrag</title>
    <meta name="description" content="Blog from Dominik" />
    <meta name="author" content="hrdominik" />
    <!-- Additional CSS Files -->
    <link rel="stylesheet" type="text/css" href="../assets/bootstrap-5/css/bootstrap-grid.min.css" />
    <link rel="stylesheet" type="text/css" href="../assets/bootstrap-5/css/bootstrap.css" />

    <!-- <script type="text/javascript" src="assets/jquery/jquery-3.6.3.min.js"></script> -->
    <script type="text/javascript" src="../assets/bootstrap-5/js/bootstrap.bundle.min.js"></script>
    <link rel="stylesheet" href="../assets/css/style.css" />
</head>

<body>
    <div class="container page-intro">
        <div class="row">
          <div class="col-5">
              <div id="titel" class="row justify-content-center align-self-center image-round mt-3">
                  <div class="col col-3"><a class="d-flex justify-content-around align-self-center desktop-only-im" href="/"><img src="../static/DHR_squared.png" alt="Dominik, myself as a portrait for business" style="width: 50%; min-width: 60px;" /></a></div>
                  <div id="titel-text" class="text-center col col-9 mt-3">
                    <h4>Dominik Höhr</h4>
                    <span>Student | DevOps @ CGI</span>
                  </div>
              </div>
          </div>
          <div class="col col-7 mt-4" style="text-align: center;">
              <h2>Blogeintrag</h2>
          </div>
          <div class="line-dec"></div>
        </div>
    </div>
    <div class="page-wrapper container blog-entry">
        <div class="row heading">
            <h1 class="display-5">Docker Compose and Database Connections</h1>
            <p class="lead">Ever run into problems connecting your app to its database in Docker&nbsp;Compose?</p>
            <hr class="my-4">
        </div>

        <div class="row justify-content-around align-self-center text-center">
            <p>In the world of containerized applications, efficiently managing database connections is crucial to application architecture. When designing your Docker&nbsp;Compose setup, you’ll inevitably face an important architectural decision: should you run your database inside your Docker&nbsp;Compose environment alongside your application containers, or should you connect to a database running directly on your host machine?</p>

            <p>Both approaches have their merits and challenges, affecting everything from performance and security to your development workflow and production deployment. This decision isn’t just a technical one—it reflects your priorities regarding isolation, resource management, and operational convenience.</p>

            <ul>
            <li><b>Database Inside Docker Compose:</b> Run your database as a service within your Docker Compose configuration, creating a self-contained ecosystem of containers.</li>
            <li><b>Host Database Connection:</b> Configure your application containers to connect to a database instance running natively on your host machine, outside the Docker environment.</li>
            </ul>

            <p>We’ll examine the technical considerations, configuration differences, and practical implications of each approach. By the end of this guide, you’ll have a clearer understanding of which strategy aligns best with your use case and development philosophy. Let’s dive in.</p>

            <h2 id="db-inside-compose">Option 1: Database Inside Docker Compose</h2>

            <h3>Why you might choose this</h3>
            <ul>
            <li><strong>Isolation &amp; parity</strong> – Dev, CI, and prod all run the same container image.</li>
            <li><strong>One-command bootstrap</strong> – <code>docker compose up -d</code> starts app and DB; contributors need only Docker.</li>
            <li><strong>Network simplicity and security</strong> – Services communicate over an internal bridge network (<code>db:5432</code>); the database is isolated from the host network.</li>
            <li><strong>Easy teardown</strong> – Removing the stack leaves no stray processes on the host.</li>
            </ul>

            <h3>Potential drawbacks</h3>
            <ul>
            <li><strong>Resource contention</strong> – Containers and the database compete for host CPU/RAM.</li>
            <li><strong>Data persistence strategy</strong> – You must define volumes for durable storage.</li>
            <li><strong>Observability tooling</strong> – Host-level monitoring agents may not see inside the container.</li>
            </ul>

            <div class="alert">
            In this guide, a PostgreSQL database is used as an example, but the same principles apply to MySQL&nbsp;(MariaDB), MongoDB, and most other databases.
            </div>

            <h3>Typical <code>docker-compose.yml</code></h3>
            <pre><code class="language-yaml">version: "3.9"
        services:
        app:
            build: .
            ports:
            - "3000:3000"
            depends_on:
            db:
                condition: service_healthy
            environment:
            DATABASE_URL: "postgresql://myuser:mypassword@db:5432/mydb"

        db:
            image: postgres:16-alpine
            restart: always
            environment:
            POSTGRES_DB: mydb
            POSTGRES_USER: myuser
            POSTGRES_PASSWORD: mypassword
            volumes:
            - db_data:/var/lib/postgresql/data

        volumes:
        db_data:</code></pre>

            <h4>Health check (prevents race conditions)</h4>
            <p>PostgreSQL:</p>
            <pre><code class="language-yaml">db:
        healthcheck:
            test: ["CMD-SHELL", "pg_isready -U $$POSTGRES_USER"]
            interval: 10s
            timeout: 5s
            retries: 5</code></pre>

            <p>MySQL / MariaDB:</p>
            <pre><code class="language-yaml">db:
        healthcheck:
            test: ["CMD-SHELL", "mysqladmin ping -h localhost -u $$MYSQL_USER -p$$MYSQL_PASSWORD"]
            interval: 10s
            timeout: 5s
            retries: 5</code></pre>

            <h4>Networking choices</h4>
            <ul>
            <li><strong>Default bridge</strong> – Compose auto-creates it; reach the DB via <code>db:5432</code>.</li>
            <li><strong>Custom bridge</strong> – Group multiple stacks:<br><code class="language-yaml">networks: { backend: { driver: bridge } }</code></li>
            <li><strong>Sidecar reuse</strong> – Extra tools in the DB’s namespace:<br><code class="language-yaml">network_mode: "service:db"</code></li>
            <li><strong><code>network_mode: host</code></strong> – Rare here; sacrifices isolation and portability.</li>
            </ul>

            <h4>Volume strategies</h4>
            <ul>
            <li><strong>Named volumes</strong> – <code>db_data</code> persists data across restarts.</li>
            <li><strong>Anonymous volumes</strong> – Use for throw-away CI runs; data is discarded when the stack stops.</li>
            <li><strong>Bind mounts</strong> – Mount local files or directories for seed scripts or custom configs, e.g.&nbsp;<code>./seed-scripts:/docker-entrypoint-initdb.d</code>.</li>
            </ul>

            <h4><code>DB_HOST</code> environment value</h4>
            <p>Inside Compose, reference the service name:</p>
            <pre><code class="language-yaml">environment:
        DB_HOST: db</code></pre>

            <p><em>Tip:</em> Store credentials in <code>.env</code> and reference them with <code>${VAR}</code>.</p>

            <h2 id="host-db">Option 2: Database on the Host Machine</h2>

            <h3>Why you might choose this</h3>
            <ul>
            <li><strong>Native performance</strong> – The database runs directly on the OS with full I/O throughput.</li>
            <li><strong>Best-of-breed backup tooling</strong> – Use host snapshots, rsync, or enterprise agents already tuned for the server DB.</li>
            <li><strong>GUI convenience</strong> – DBeaver, pgAdmin, or TablePlus connect to <code>localhost</code> without port forwarding.</li>
            <li><strong>Shared single instance</strong> – Multiple Compose projects can reuse the same DB for rapid prototyping.</li>
            </ul>

            <h3>Potential drawbacks</h3>
            <ul>
            <li><strong>Less isolation</strong> – A misconfigured app can affect the host DB—and vice-versa.</li>
            <li><strong>Onboarding friction</strong> – Every team member must install and configure the DB natively.</li>
            <li><strong>Prod-dev drift</strong> – Production is usually containerized or remote-managed; running natively in dev breaks parity.</li>
            </ul>

            <h3>Connecting from Compose</h3>
            <pre><code class="language-yaml">services:
        app:
            build: .
            ports:
            - "3000:3000"
            environment:
            DATABASE_URL: "postgresql://myuser:mypassword@host.docker.internal:5432/mydb"
            extra_hosts:
            - "host.docker.internal:host-gateway"</code></pre>

            <h4>Health checks</h4>
            <p>The DB runs outside Compose, so health monitoring happens via host tooling (systemd, monit). The app container can still expose its own health check.</p>

            <h4>Networking choices</h4>
            <ul>
            <li><strong>Default bridge + <code>host.docker.internal</code></strong> – Works on macOS, Windows, and Docker&nbsp;≥ 20.10 on Linux.</li>
            <li><strong><code>network_mode: host</code></strong> – Lets the container reach <code>127.0.0.1</code>; Linux only; no port isolation.</li>
            <li>Sidecar networks do not apply—there is no DB container to share.</li>
            </ul>

            <h4>Volume considerations</h4>
            <p>Because the DB lives on the host, Compose volumes are largely irrelevant unless the app needs to mount tls certs or similar. Real data resides in the host’s DB data directory, where existing backups already run.</p>

            <h4><code>DB_HOST</code> environment value</h4>
            <pre><code class="language-yaml">DB_HOST: host.docker.internal
        # If using network_mode: host
        DB_HOST: 127.0.0.1</code></pre>

            <p><em>Remember:</em> The database must listen on a TCP port; Unix sockets such as <code>/var/run/postgresql</code> are not visible inside container names-paces.</p>

            <h2 id="decision">How to choose?</h2>
            <ul>
            <li><strong>I need dev/prod parity</strong> → Prefer <a href="#db-inside-compose">inside Compose</a>.</li>
            <li><strong>I frequently restart containers but want data to survive</strong> → Inside Compose with a named volume.</li>
            <li><strong>I already have a tuned Postgres instance on the host</strong> → <a href="#host-db">host DB</a> may be simpler.</li>
            <li><strong>I am low on laptop RAM</strong> → A single host DB can save resources.</li>
            <li><strong>I’m onboarding new contributors</strong> → One-command Compose stack wins.</li>
            </ul>

            <h2 id="best-practices">Universal Best Practices</h2>
            <ol>
            <li><strong>Secrets management</strong> – Use <code>.env</code>, <code>docker compose --env-file</code>, or a secret manager; never bake passwords into images.</li>
            <li><strong>Backups</strong> – Use volumes in Compose or schedule <code>pg_dump</code> on the host and test restores.</li>
            <li><strong>Health checks</strong> – Add <code>healthcheck:</code> in Compose or systemd <code>Restart=on-failure</code> for host services.</li>
            <li><strong>Apply migrations early</strong> – Run Flyway, Liquibase, or <code>prisma migrate</code> at container start so the schema matches code.</li>
            <li><strong>Use minimal images</strong> – Alpine, Bitnami, or the official images save bandwidth and start faster.</li>
            </ol>

            <h2 id="conclusion">Wrapping up</h2>
            <p>Whether you embed the database in your Compose file or connect outward to a host-level service, the key is consistency. Pick the workflow that mirrors production most closely while keeping your development loop tight and reliable. With clear volume strategies, explicit connection strings, and automated migrations, your application will feel at home in either setup. Happy containerizing!</p>
        </div>
        </div>

    <div class="container page-end">
        <div class="row justify-content-around align-self-center mt-3 text-center">
            <div class="col-8 col-lg-5 link-button"><a id="home" href="https://dominik.hoehr.net"> &laquo; Zurück zur Webseite</a></div>        
        </div>
        <div class="row justify-content-center align-self-center mt-3 text-center">
            <div class="col">
                <a href="../impressum.html">Impressum</a>
            </div>
            <div class="col">
                <a href="../datenschutzerklaerung.html">Datenschutzerklärung</a>
            </div>
        </div>
    </div>
</body>
</html>